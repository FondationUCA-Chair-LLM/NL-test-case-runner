import z from "zod";
import { Obs } from "./Observe.js";
import { Page} from "@browserbasehq/stagehand";

interface ElementRow {
  id: string;
  type: string;
  description: string | null;
}

/**
 * Parses a structured text input and extracts elements into tabular format
 * @param input Raw text with elements
 * @returns Array of structured rows { id, type, description }
 */
export function parseElements(input: string|undefined): ElementRow[] {
  if (!input) return [];
  const lines = input.split(/\r?\n/).map(l => l.trim()).filter(Boolean);
  const results: ElementRow[] = [];

  for (const line of lines) {
    // Capture the full bracketed id (everything between [ and ]) and the rest
    const m = line.match(/^\s*(\[[^\]]+\])\s*(.*)$/);
    if (!m) continue;

    const [, id, rest] = m;
    const content = rest.trim();

    if (content === "") {
      results.push({ id, type: "", description: null });
      continue;
    }

    const colonIndex = content.indexOf(":");
    if (colonIndex !== -1) {
      const type = content.slice(0, colonIndex).trim();
      const description = content.slice(colonIndex + 1).trim();
      results.push({ id, type, description: description || null });
    } else {
      // No colon => treat the whole token as description, type is empty string
      results.push({ id, type: "", description: content });
    }
  }

  return results;
}


export async function extract(data: Obs,page: Page, ret?: z.AnyZodObject, terms?: string): Promise<string> {
  var result = "{\n";
  //insert content generated by Obserce
  result += Obs.eleToJson(data.links, "link");
  result += Obs.eleToJson(data.buttons, "button");
  result += Obs.eleToJson(data.checkboxes, "checkbox");
  result += Obs.eleToJson(data.fields, "field");
  result += Obs.eleToJson(data.forms, "form");
  result += Obs.eleToJson(data.selects, "select");
  result += Obs.eleToJson(data.statictText, "StaticText");
  //extract
    ret = z.object({
      elements : z.array(
      z.object({
      id: z.string(),
      description: z.string(),
      type: z.string()      
    }))});

const cpage = await page.extract();
const results = parseElements(cpage.page_text);
console.debug("Parsed elements:", results);

    for(var k=0; k<results.length; k++) {
      result += "{\"id\": "+results[k].id+", \"description\": "+results[k].description+", \"type\": "+results[k].type+"}\n";
    }
    result += "}";
    console.debug("%%%%%%%%%%%%%%%%%%%%Extract%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%");
    console.debug(result);
    return result;
  }

// Découpe la donnée en chunks 
export function splitWithOverlap(data: string, chunkSize = 3000, overlap = 20): string[] {
  const chunks: string[] = [];
  let start = 0;
  while (start < data.length) {
    const end = Math.min(start + chunkSize, data.length);
    chunks.push(data.slice(start, end));
    if (end === data.length) break;
    start = end - overlap;
  }
  return chunks;
}
